4. Median of Two Sorted Arrays

There are two sorted arrays nums1 and nums2 of size m and n respectively.

Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).

Example 1:
nums1 = [1, 3]
nums2 = [2]

The median is 2.0
Example 2:
nums1 = [1, 2]
nums2 = [3, 4]

The median is (2 + 3)/2 = 2.5

奇数：1 2 3 4 5 6 7 8 9
             5
     1 2+3 4 5 6 7 8 9  B[2]

     1 2 3 4 5 6+7 8 9  A[4]


1. 找中位数-->>将这个问题放大到，寻找两个已排序好的数组，求第k小的数。

2. 注意 两个数组是已经排序好的了，如果不将两个数组合并的前提下，该如何做呢？

3. 一共有两个数组，如果总长度为奇数，那么第k小的数必然在其中的一个数组中。可能是A数组的第p位或者是B数组的第q位,但是p+q=k。
   如果总长度为偶数，则有可能会各用到两个数组中的一个数，相加除以2。总之是第k位和第k+1位之和除以二。
   p+q等于k-1,且一序列第p个元素和二序列第q个元素都小于总序列第k个元素。因为总序列中，必然有k-1个元素小于等于第k个元素。
   这样第p+1个元素或者第q+1个元素就是我们要找的第k个元素。

4. 所以，我们可以通过二分法将问题规模缩小，假设p=k/2-1，则q=k-p-1，且p+q=k-1。所以一开始选取p和q只能瞎猜，默认p=k/2，但有可能k在p的右边
   如果第一个序列第p个元素小于第二个序列第q个元素，我们不确定二序列第q个元素跟k相比是大了还是小了，但一序列的前p个元素肯定都小于目标，
   所以我们将第一个序列前p个元素全部抛弃，形成一个较短的新序列。
   然后，用新序列替代原先的第一个序列，再找其中的第k-p个元素（因为我们已经排除了p个元素，k需要更新为k-p），依次递归。
   同理，如果第一个序列第p个元素大于第二个序列第q个元素，我们则抛弃第二个序列的前q个元素。递归的终止条件有如下几种：

   较短序列所有元素都被抛弃，则返回较长序列的第k个元素（在数组中下标是k-1）
   一序列第p个元素等于二序列第q个元素，此时总序列第p+q=k-1个元素的后一个元素，也就是总序列的第k个元素

   每次递归不仅要更新数组起始位置（起始位置之前的元素被抛弃），也要更新k的大小（扣除被抛弃的元素）
